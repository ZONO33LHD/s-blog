package resolver

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.70

import (
	"context"
	"fmt"
	"log"

	"github.com/google/uuid"
	domainmodel "github.com/s-blog/backend/go-server/domain/model"
	"github.com/s-blog/backend/go-server/interface/graphql/generated"
	gqlmodel "github.com/s-blog/backend/go-server/interface/graphql/model"
	"gorm.io/gorm"
)

// Articles is the resolver for the articles field.
func (r *queryResolver) Articles(ctx context.Context) ([]*gqlmodel.Article, error) {
	var domainArticles []*domainmodel.Article
	log.Println("Fetching articles from database...")
	err := r.DB.Order("published_at desc").
		Preload("Author").
		Preload("Tags").
		Find(&domainArticles).Error

	if err != nil {
		log.Printf("Error fetching articles from DB: %v\\n", err)
		return nil, fmt.Errorf("internal system error")
	}
	log.Printf("Fetched %d articles from database.", len(domainArticles))

	gqlArticles := make([]*gqlmodel.Article, 0, len(domainArticles))
	for i, article := range domainArticles {
		log.Printf("Mapping article %d: %s", i, article.Title)
		var publishedAtStr string
		if article.PublishedAt != nil {
			publishedAtStr = article.PublishedAt.String()
		}

		// Author and Tags are now preloaded
		var authorName, authorAvatar string
		if article.Author.ID != uuid.Nil { // Check if Author is valid
			authorName = article.Author.Name
			authorAvatar = article.Author.Avatar
		}
		tags := make([]string, 0, len(article.Tags))
		for _, tag := range article.Tags {
			tags = append(tags, tag.Name)
		}

		gqlArticle := &gqlmodel.Article{
			ID:          article.ID.String(),
			Title:       article.Title,
			Content:     article.Content,
			Excerpt:     article.Excerpt,
			PublishedAt: publishedAtStr,
			Author: &gqlmodel.Author{
				Name:   authorName,
				Avatar: authorAvatar,
				Bio:    nil,
			},
			Tags:        tags,
			Likes:       0,
			Comments:    []*gqlmodel.Comment{}, // Empty slice
			ReadingTime: nil,
		}
		gqlArticles = append(gqlArticles, gqlArticle)
		log.Printf("Finished mapping article %d", i)
	}
	log.Println("Finished mapping all articles.")

	return gqlArticles, nil
}

// ArticlesByTag is the resolver for the articlesByTag field.
func (r *queryResolver) ArticlesByTag(ctx context.Context, tag string) ([]*gqlmodel.Article, error) {
	var domainArticles []*domainmodel.Article
	log.Printf("Fetching articles for tag: %s", tag)
	err := r.DB.Joins("JOIN article_tags ON article_tags.article_id = articles.id").
		Joins("JOIN tags ON tags.id = article_tags.tag_id").
		Preload("Author").
		Preload("Tags").
		Where("tags.name = ?", tag).
		Find(&domainArticles).Error

	if err != nil {
		log.Printf("Error fetching articles by tag '%s': %v\\n", tag, err)
		return nil, fmt.Errorf("failed to fetch articles by tag")
	}
	log.Printf("Fetched %d articles for tag: %s", len(domainArticles), tag)

	gqlArticles := make([]*gqlmodel.Article, 0, len(domainArticles))
	for _, article := range domainArticles {
		var publishedAtStr string
		if article.PublishedAt != nil {
			publishedAtStr = article.PublishedAt.String()
		}
		var authorName, authorAvatar string
		if article.Author.ID != uuid.Nil { // Check if Author is valid
			authorName = article.Author.Name
			authorAvatar = article.Author.Avatar
		}
		tags := make([]string, 0, len(article.Tags))
		for _, t := range article.Tags { // Use preloaded Tags
			tags = append(tags, t.Name)
		}

		gqlArticle := &gqlmodel.Article{
			ID:          article.ID.String(),
			Title:       article.Title,
			Content:     article.Content,
			Excerpt:     article.Excerpt,
			PublishedAt: publishedAtStr,
			Author: &gqlmodel.Author{
				Name:   authorName,
				Avatar: authorAvatar,
				Bio:    nil,
			},
			Tags:        tags,
			Likes:       0,
			Comments:    []*gqlmodel.Comment{},
			ReadingTime: nil,
		}
		gqlArticles = append(gqlArticles, gqlArticle)
	}
	log.Printf("Finished mapping %d articles for tag: %s", len(gqlArticles), tag)
	return gqlArticles, nil
}

// TrendingArticles is the resolver for the trendingArticles field.
func (r *queryResolver) TrendingArticles(ctx context.Context) ([]*gqlmodel.Article, error) {
	var domainArticles []*domainmodel.Article
	log.Println("Fetching trending articles...")
	err := r.DB.Order("published_at desc").
		Limit(5).
		Preload("Author").
		Preload("Tags").
		Find(&domainArticles).Error

	if err != nil {
		log.Printf("Error fetching trending articles: %v\\n", err)
		return nil, fmt.Errorf("failed to fetch trending articles")
	}
	log.Printf("Fetched %d trending articles.", len(domainArticles))

	gqlArticles := make([]*gqlmodel.Article, 0, len(domainArticles))
	for _, article := range domainArticles {
		var publishedAtStr string
		if article.PublishedAt != nil {
			publishedAtStr = article.PublishedAt.String()
		}
		var authorName, authorAvatar string
		if article.Author.ID != uuid.Nil { // Check if Author is valid
			authorName = article.Author.Name
			authorAvatar = article.Author.Avatar
		}
		tags := make([]string, 0, len(article.Tags))
		for _, tag := range article.Tags {
			tags = append(tags, tag.Name)
		}

		gqlArticle := &gqlmodel.Article{
			ID:          article.ID.String(),
			Title:       article.Title,
			Content:     article.Content,
			Excerpt:     article.Excerpt,
			PublishedAt: publishedAtStr,
			Author: &gqlmodel.Author{
				Name:   authorName,
				Avatar: authorAvatar,
				Bio:    nil,
			},
			Tags:        tags,
			Likes:       0,
			Comments:    []*gqlmodel.Comment{},
			ReadingTime: nil,
		}
		gqlArticles = append(gqlArticles, gqlArticle)
	}
	log.Printf("Finished mapping %d trending articles.", len(gqlArticles))
	return gqlArticles, nil
}

// Article is the resolver for the article field.
func (r *queryResolver) Article(ctx context.Context, id string) (*gqlmodel.Article, error) {
	log.Printf("Fetching article with ID: %s", id)
	var domainArticle domainmodel.Article
	parsedID, err := uuid.Parse(id)
	if err != nil {
		log.Printf("Error parsing article ID '%s': %v", id, err)
		return nil, fmt.Errorf("invalid article ID format")
	}

	err = r.DB.Preload("Author").
		Preload("Tags").
		First(&domainArticle, "id = ?", parsedID).Error

	if err != nil {
		if err == gorm.ErrRecordNotFound {
			log.Printf("Article with ID '%s' not found", id)
			return nil, nil
		} else {
			log.Printf("Error fetching article with ID '%s' from DB: %v", id, err)
			return nil, fmt.Errorf("internal system error")
		}
	}
	log.Printf("Fetched article: %s", domainArticle.Title)

	var publishedAtStr string
	if domainArticle.PublishedAt != nil {
		publishedAtStr = domainArticle.PublishedAt.String()
	}
	var authorName, authorAvatar string
	if domainArticle.Author.ID != uuid.Nil { // Check if Author is valid
		authorName = domainArticle.Author.Name
		authorAvatar = domainArticle.Author.Avatar
	}
	tags := make([]string, 0, len(domainArticle.Tags))
	for _, tag := range domainArticle.Tags {
		tags = append(tags, tag.Name)
	}

	gqlArticle := &gqlmodel.Article{
		ID:          domainArticle.ID.String(),
		Title:       domainArticle.Title,
		Content:     domainArticle.Content,
		Excerpt:     domainArticle.Excerpt,
		PublishedAt: publishedAtStr,
		Author: &gqlmodel.Author{
			Name:   authorName,
			Avatar: authorAvatar,
			Bio:    nil,
		},
		Tags:        tags,
		Likes:       0,
		Comments:    []*gqlmodel.Comment{}, // Correct type, empty slice
		ReadingTime: nil,
	}

	log.Printf("Finished mapping article with ID: %s", id)
	return gqlArticle, nil
}

// Query returns generated.QueryResolver implementation.
func (r *Resolver) Query() generated.QueryResolver { return &queryResolver{r} }

type queryResolver struct{ *Resolver }

// !!! WARNING !!!
// The code below was going to be deleted when updating resolvers. It has been copied here so you have
// one last chance to move it out of harms way if you want. There are two reasons this happens:
//  - When renaming or deleting a resolver the old code will be put in here. You can safely delete
//    it when you're done.
//  - You have helper methods in this file. Move them out to keep these resolver files clean.
/*
	type ArticleResolver interface {
	Comments(ctx context.Context, obj *gqlmodel.Article) ([]*gqlmodel.Comment, error)
	// Author(ctx context.Context, obj *gqlmodel.Article) (*gqlmodel.Author, error) // 必要に応じて Author リゾルバを追加
}
type articleResolver struct{ *Resolver }
func (r *Resolver) Article() ArticleResolver { return &articleResolver{r} }
func (r *articleResolver) Comments(ctx context.Context, obj *gqlmodel.Article) ([]*gqlmodel.Comment, error) {
	log.Printf("Fetching comments for article ID: %s", obj.ID)
	var domainComments []*domainmodel.Comment

	articleID, err := uuid.Parse(obj.ID)
	if err != nil {
		log.Printf("Error parsing article ID '%s' in Comments resolver: %v", obj.ID, err)
		return nil, fmt.Errorf("internal error resolving comments")
	}

	// Fetch comments associated with the article ID, preload author (User)
	err = r.DB.Preload("User"). // Assuming domainmodel.Comment has a User field linked to users table
					Where("article_id = ?", articleID).
					Order("created_at desc").
					Find(&domainComments).Error

	if err != nil {
		log.Printf("Error fetching comments for article ID '%s' from DB: %v", obj.ID, err)
		// Don't return internal error directly, maybe empty list is better?
		// Consider returning empty list and logging the error
		return []*gqlmodel.Comment{}, nil // Return empty list on error for now
	}
	log.Printf("Fetched %d comments for article ID: %s", len(domainComments), obj.ID)

	gqlComments := make([]*gqlmodel.Comment, 0, len(domainComments))
	for _, comment := range domainComments {
		var createdAtStr string
		if !comment.CreatedAt.IsZero() {
			createdAtStr = comment.CreatedAt.String()
		}

		var authorName, authorAvatar string
		if comment.User.ID != uuid.Nil { // Check if associated User is valid
			authorName = comment.User.Name
			authorAvatar = comment.User.Avatar
		} else {
			log.Printf("Warning: Author (User) is nil or invalid for comment ID %s", comment.ID.String())
		}

		gqlComment := &gqlmodel.Comment{
			ID:        comment.ID.String(),
			Content:   comment.Content,
			CreatedAt: createdAtStr,
			Author: &gqlmodel.Author{ // Map comment author (User)
				Name:   authorName,
				Avatar: authorAvatar,
				Bio:    nil, // Bio not available on comment author typically
			},
		}
		gqlComments = append(gqlComments, gqlComment)
	}
	log.Printf("Finished mapping %d comments for article ID: %s", len(gqlComments), obj.ID)
	return gqlComments, nil
}
*/
